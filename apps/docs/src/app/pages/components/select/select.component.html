<section class="page">
  <header id="overview" class="doc-card doc-card--intro section-anchor">
    <h2 class="docs-h1">Select</h2>
    <p class="overview-lead">
      Select enables a deliberate choice from a predefined set of mutually exclusive options,
      presented in a compact dropdown.
    </p>
  </header>

  <nav class="section-tabs">
    <a
      href="#overview"
      (click)="scrollToSection($event, 'overview')"
      [class.active]="currentSection === 'overview'"
    >
      Overview
    </a>
    <a
      href="#grouping"
      (click)="scrollToSection($event, 'grouping')"
      [class.active]="currentSection === 'grouping'"
    >
      Grouping
    </a>
    <a
      href="#usage"
      (click)="scrollToSection($event, 'usage')"
      [class.active]="currentSection === 'usage'"
    >
      Usage
    </a>
    <a
      href="#interaction"
      (click)="scrollToSection($event, 'interaction')"
      [class.active]="currentSection === 'interaction'"
    >
      Interaction
    </a>
    <a
      href="#accessibility"
      (click)="scrollToSection($event, 'accessibility')"
      [class.active]="currentSection === 'accessibility'"
    >
      Accessibility
    </a>
    <a
      href="#properties"
      (click)="scrollToSection($event, 'properties')"
      [class.active]="currentSection === 'properties'"
    >
      Properties
    </a>
  </nav>

  <section class="section doc-card overview-content">
    <p class="section-lead">
      Selects are ideal when the user must choose one value from a limited list. They rely on
      native select behavior and accessibility, while Percepta customizes visual appearance
      through design tokens.
    </p>
    <p class="section-lead">
      Interaction, keyboard behavior, and option grouping are owned by the framework. Percepta
      does not redefine select semantics; it ensures visual consistency across the interface.
    </p>
    <h3 class="docs-h2">Preview</h3>
    <div class="demo-box demo-box--canonical">
      <div class="demo-row demo-row--stack canonical-demo">
        <div class="demo-center">
          <div class="demo-field">
            <label for="select-preview">City</label>
            <p-select
              inputId="select-preview"
              styleClass="demo-control"
              [options]="options"
              optionLabel="label"
              placeholder="Choose a city"
              [checkmark]="true"
              [(ngModel)]="selectedDefault"
            ></p-select>
          </div>
        </div>
      </div>
    </div>
  </section>

  <section class="section doc-card">
    <h3 id="grouping" class="section-anchor docs-h2">Grouping options</h3>
    <p class="docs-body">
      Use optgroups to organize long lists into meaningful clusters so users can scan faster.
    </p>
    <h4 class="docs-h3">Native select (HTML)</h4>
    <p class="docs-body">
      This example shows the native HTML select using optgroup semantics, rendered by the browser
      without visual customization.
    </p>
    <div class="demo-box">
      <div class="demo-row demo-row--left">
        <div class="demo-center">
          <div class="demo-field">
            <label for="native-select-grouped">Office</label>
            <select id="native-select-grouped" class="demo-control demo-control--native">
              <optgroup label="Europe">
                <option>Barcelona</option>
                <option>Milan</option>
                <option>Paris</option>
              </optgroup>
              <optgroup label="Americas">
                <option>Buenos Aires</option>
                <option>Mexico City</option>
                <option>New York</option>
              </optgroup>
            </select>
          </div>
        </div>
      </div>
    </div>
    <h4 class="docs-h3">Custom select</h4>
    <p class="docs-body">
      This example shows a custom select rendered by the framework, using the same grouping semantics
      while allowing visual customization through design tokens.
    </p>
    <div class="demo-box">
      <div class="demo-row demo-row--left">
        <div class="demo-center">
          <div class="demo-field">
            <label for="select-grouped">Office</label>
            <p-select
              inputId="select-grouped"
              styleClass="demo-control"
              [options]="groupedOptions"
              optionLabel="label"
              optionGroupLabel="label"
              optionGroupChildren="items"
              [group]="true"
              placeholder="Select a city"
              [checkmark]="true"
              [(ngModel)]="selectedGrouped"
            ></p-select>
          </div>
        </div>
      </div>
    </div>
    <p class="docs-body">
      Both examples use the same grouping semantics. The difference lies in presentation and
      customization: native selects rely on browser rendering, while custom implementations enable
      a dropdown panel styled by the design system.
    </p>
  </section>

  <section class="section doc-card">
    <h3 id="usage" class="section-anchor docs-h2">Usage</h3>

    <p class="docs-body">
      Selects are best used when the user needs to make a deliberate choice from a known set of options.
      They introduce a moment of decision, so they should be clear, intentional, and easy to scan.
    </p>

    <p class="docs-body">
      A well-designed select helps users understand what they are choosing, why it matters, and what
      will happen next.
    </p>

    <h4 class="docs-h3">Do</h4>
    <ul class="docs-list">
      <li>Make the purpose obvious at a glance through clear labels and surrounding context.</li>
      <li>Use labels as anchors, not placeholders, to provide stable meaning.</li>
      <li>Structure options so relevant choices are easy to find and compare.</li>
      <li>Preselect a value only when it reflects a likely or previously known choice.</li>
      <li>Leave the field empty when the decision requires explicit user intent.</li>
      <li>Use helper text to clarify consequences, scope, or constraints when needed.</li>
      <li>Introduce filtering or search when option lists grow beyond quick scanning.</li>
      <li>Use selects to drive navigation or state changes when the selection directly affects the UI.</li>
    </ul>

    <h4 class="docs-h3">Don’t</h4>
    <ul class="docs-list">
      <li>Don’t use selects for trivial or highly familiar data.</li>
      <li>Don’t rely on placeholder text to explain the purpose of the field.</li>
      <li>Don’t force instructional defaults that add noise instead of clarity.</li>
      <li>Don’t present long, unstructured lists that slow down decision-making.</li>
      <li>Don’t assume context when the meaning is not immediately clear.</li>
    </ul>
  </section>

  <section class="section doc-card">
    <h3 id="interaction" class="section-anchor docs-h2">Interaction mapping</h3>
    <p class="docs-body">
      This section maps semantic design roles to select states without exposing raw values.
    </p>
    <p class="docs-body">
      Select states are consistent with other form controls. Percepta does not introduce custom
      interaction states and maps semantic roles to framework-owned behavior.
    </p>
    <table class="mapping-table">
      <thead>
        <tr>
          <th>State</th>
          <th>Background role</th>
          <th>Border role</th>
          <th>Foreground role</th>
          <th>Placeholder role</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Label</td>
          <td>—</td>
          <td>—</td>
          <td>Foreground · Default</td>
          <td>—</td>
        </tr>
        <tr>
          <td>Default</td>
          <td>Background · Default</td>
          <td>Border · Subtle</td>
          <td>Foreground · Subtle</td>
          <td>Foreground · Subtle</td>
        </tr>
        <tr>
          <td>Hover</td>
          <td>Background · Default</td>
          <td>Border · Muted</td>
          <td>Foreground · Subtle</td>
          <td>Foreground · Subtle</td>
        </tr>
        <tr>
          <td>Focus</td>
          <td>Background · Default</td>
          <td>Border · Focus</td>
          <td>Foreground · Default</td>
          <td>Foreground · Subtle</td>
        </tr>
        <tr>
          <td>Error</td>
          <td>Background · Error</td>
          <td>Border · Error</td>
          <td>Foreground · Subtle</td>
          <td>Foreground · Subtle</td>
        </tr>
        <tr>
          <td>Disabled</td>
          <td>Background · Disabled</td>
          <td>Border · Disabled</td>
          <td>Foreground · Disabled</td>
          <td>Foreground · Disabled</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section class="section doc-card">
    <h3 id="accessibility" class="section-anchor docs-h2">Accessibility</h3>
    <p class="docs-body">
      The underlying framework handles keyboard and ARIA behaviors. Keep visible labels and
      descriptive helper text to preserve accessible navigation.
    </p>
    <ul class="docs-list">
      <li>Keyboard: Tab to focus, Space/Enter to open, arrows to move, Enter to select, Esc to close.</li>
      <li>Always provide a visible label; use aria-label only when the label is hidden.</li>
      <li>Announce helper or error text when present.</li>
    </ul>
    <p class="docs-body">
      Percepta does not override accessibility behavior and relies on native semantics and the
      framework implementation.
    </p>
  </section>

  <section class="section doc-card">
    <h3 id="properties" class="section-anchor docs-h2">Properties</h3>
    <table class="mapping-table">
      <thead>
        <tr>
          <th>Property</th>
          <th>Values</th>
          <th>Required</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>options</td>
          <td>SelectOption[]</td>
          <td>No</td>
        </tr>
        <tr>
          <td>groups</td>
          <td>SelectGroup[]</td>
          <td>No</td>
        </tr>
        <tr>
          <td>label</td>
          <td>string</td>
          <td>No</td>
        </tr>
        <tr>
          <td>placeholder</td>
          <td>string</td>
          <td>No</td>
        </tr>
        <tr>
          <td>disabled</td>
          <td>boolean</td>
          <td>No</td>
        </tr>
        <tr>
          <td>value</td>
          <td>string | number | null</td>
          <td>No</td>
        </tr>
        <tr>
          <td>helperText</td>
          <td>string</td>
          <td>No</td>
        </tr>
        <tr>
          <td>errorText</td>
          <td>string</td>
          <td>No</td>
        </tr>
      </tbody>
    </table>
  </section>
</section>
